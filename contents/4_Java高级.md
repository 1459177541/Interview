## Java高级



# 多线程
## ！1、进程和线程的区别

## ！2、并行和并发的区别和联系

并发（concurrency）和并行（parallellism）是：

* 解释一：并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。
* 解释二：并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。
* 解释三：在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群
> 所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。

## ！3、同步与异步

1.同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)
>所谓同步，就是在发出一个**调用**时，在没有得到结果之前，该**调用**就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由**调用者**主动等待这个**调用**的结果。

> 而异步则是相反，**调用**在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在**调用**发出后，
**被调用者**通过状态、通知来通知调用者，或通过回调函数处理这个调用。



## ！4、多线程的实现方式，有什么区别

## ！5、什么叫守护线程

> Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程)

> 用户线程即运行在前台的线程，而守护线程是运行在后台的线程。 守护线程作用是为其他前台线程的运行提供便利服务，而且仅在普通、非守护线程仍然运行时才需要，
比如垃圾回收线程就是一个守护线程。当VM检测仅剩一个守护线程，而用户线程都已经退出运行时，VM就会退出，因为没有如果没有了被守护这，也就没有继续运行程序的必要了。
如果有非守护线程仍然存活，VM就不会退出。

> 守护线程并非只有虚拟机内部提供，用户在编写程序时也可以自己设置守护线程。用户可以用Thread的setDaemon（true）方法设置当前线程为守护线程。

> 虽然守护线程可能非常有用，但必须小心确保其他所有非守护线程消亡时，不会由于它的终止而产生任何危害。因为你不可能知道在所有的用户线程退出运行前，守护线程是否已经完成了预期的服务任务。
一旦所有的用户线程退出了，虚拟机也就退出运行了。 因此，不要在守护线程中执行业务逻辑操作（比如对数据的读写等）。

>另外有几点需要注意：

 * setDaemon(true)必须在调用线程的start（）方法之前设置，否则会跑出IllegalThreadStateException异常。
 * 在守护线程中产生的新线程也是守护线程。
 * 不要认为所有的应用都可以分配给守护线程来进行服务，比如读写操作或者计算逻辑。


## %6、如何停止一个线程？

## ！7、什么是线程安全？

## ！8、synchronized 和 lock的区别

## ！9、当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?

## ！10、启动一个线程是用run()还是start()?

## ！12、wait和sleep的区别

* sleep是Thread类的方法, wait是Object类中定义的方法
* sleep 方法可能抛出一个InterruptedException,这是一个必检异常。当一个休眠线程的interrupt()方法被调用时，就会发生这个异常。
  因为java强制捕获必检的异常，所以，必须将他放到try-catch块中。如果在一个循环中调用了sleep方法，那就应该将这个循环放在
  try-catch 块中，如果循环在try-catch块外，即使线程被中断，它也可能会继续执行。而wait，notify和notifyAll不需要捕获异常。
* 监视器（monitor)是一个相互排斥且具备同步能力的对象。监视器中的一个时间点上，只能有一个线程执行一个方法。 线程通过获取监视器上的锁进入监视器，
  并且通过释放锁退出监视器。任意对象都可能是一个监视器。一旦一个线程锁住对象，该对象就成为监视器。 在执行同步方法或块之前，线程必须获取锁。
  Thread.sleep()和Object.wait()都会暂停当前的线程, sleep() 不会释放monitor ,调用wait()方法可以释放monitor, 调用wait后，需要别的线程执行notify/notifyAll
  来通知一个或所有的等待线程重新获取锁并且恢复执行。
* waite()和notify()因为会对对象的“锁标志”进行操作，所以它们必须在synchronized函数或synchronized block中进行调用。如果在non-synchronized函数或
  non-synchronizedblock中进行调用，虽然能编译通过，但在运行时会发生illegalMonitorStateException的异常

## %13、notify和notifyAll的区别

> 锁池和等待池
* 锁池: 假设线程A已经拥有了某个对象(注意:不是类)的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，
     由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权， 但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的锁池中。
* 等待池:假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁后，进入到了该对象的等待池中 
> 然后再来说notify和notifyAll的区别 
1. 如果线程调用了对象的 wait()方法， 那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。
2. 当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，
锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，
3. 等待锁竞争优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法， 它才会重新回到等待池中。
而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。
> 综上，所谓唤醒线程，另一种解释可以说是将线程由等待池移动到锁池 notifyAll调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，
如果不成功则留在锁池等待锁被释放后再次参与竞争。而notify只会唤醒一个线程。有了这些理论基础，后面的notify可能会导致死锁，而notifyAll则不会的例子也就好解释了

## %14、线程池的作用

## %15、Java中线程池相关的类

##### 参考资料
1. [java中的锁](http://www.importnew.com/19472.html)
---

# JVM底层技术
## ！1、gc的概念，如果A和B对象循环引用，是否可以被GC？

## %2、jvm gc如何判断对象是否需要回收，有哪几种方式？

## ！3、Java中能不能主动触发GC

## ！4、JVM的内存结构，堆和栈的区别

## ！5、JVM堆的分代

## %6、Java中的内存溢出是什么，和内存泄露有什么关系

## ！7、Java的类加载机制，什么是双亲委派

## ！8、ClassLoader的类加载方式

##### 参考资料

---

# IO
## ！1、NIO、AIO和BIO 之间的区别

## ？2、IO和NIO常用用法

##### 参考资料

---

# 其它
## ？1、hashcode 有哪些算法

## ！2、反射的基本概念，反射是否可以调用私有方法

## ！3、Java中范型的概念

## ？4、JVM启动参数，-Xms和 -Xmx

## %5、代理机制的实现

## ！6、String s = new String("s")，创建了几个对象。

##### 参考资料

---

> Contributors : Hollis、Kevin Lee
>
> Reviewers : Hollis、Kevin Lee
